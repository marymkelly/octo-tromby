<!DOCTYPE html>
<html>
<head>
	<title>Tromby - Trombone Simulator</title>
	<!-- Load the Paper.js library -->
	<script type="text/javascript" src="js/paper-full.js"></script>
	<script type="text/javascript" src="js/howler.js"></script>
	<!-- Define inlined PaperScript associate it with myCanvas -->
	<script type="text/paperscript" canvas="myCanvas">

	//paper/canvas variables
	var pWidth = view.bounds.width;
	var pHeight = view.bounds.height;
	var midY = pHeight / 2;
	var midX = pWidth / 2;

	var pSeventh = ((pWidth - 250) / 7);
	//shape variables
	var width = 100;
	var height = 100;
	//calculate slide positions
	var seventh = (pWidth - (width * 1.5)) / 7; 
	//rectangle for testing position
	var rectSize = new Size(width, height);
	var rectPoint = new Point(width , (midY - (rectSize.height/2)));

	//trombone vars
	var trombone;
	var slide;
	var slSvgSev;
	var initSlideX; //386.6667 center X of slide
	var maxSlideX; //1586.2 max point for center X of slide
	var offset; // // 140 from the right side of canvas 
	var slideSeventh; // equal division of 7 parts //100.07 each

	//slide svg relative ~ not canvas
	var topSlide; //initSlideX - offset; // 245 - static // top of slide and left bound of animation
	var bottomSlide; // 1085 - static
	var leftSlSvg; // ((slide.bounds.width / 2) - (pWidth / 3)); // left endpoint x of slide svg 
	var rightSlSvg; // ((slide.bounds.width / 2) + (pWidth / 3)); // right endpoint x of slide svg 


	var rect = new Shape.Rectangle(rectPoint, rectSize);
	rect.fillColor = 'blue';

	paper.project.importSVG('/images/belltb.svg', function(onload) { //background trombone image
		trombone = onload;
	
		trombone.scale(1);
		trombone.position = new Point((pWidth / 3), midY);
	});

	paper.project.importSVG('/images/slidetb.svg', function(onload) { //animated trombone slide
		slide = onload;
		
		slide.scale(1);
		console.log(slide.bounds);
		slide.position = new Point((pWidth / 3), midY); 

		slSvgSev = (slide.bounds.width / 7); // for calculating max center X
		initSlideX = slide.position.x;
		maxSlideX = initSlideX + (slide.bounds.width - slSvgSev); //supposed to be max center X

		leftSlSvg = ((slide.bounds.width / 2) - (pWidth / 3)); // left endpoint x of slide svg 
		rightSlSvg = ((slide.bounds.width / 2) + (pWidth / 3)); // right endpoint x of slide svg
		offset = (pWidth - (slide.bounds.width - (pWidth / 3))); //from right side of canvas 
		topSlide = initSlideX - offset; // 245 - static
		bottomSlide = rightSlSvg; // 1085
		slideSeventh = (bottomSlide - topSlide) / 7; 

		slide.strokeColor = "purple";
		slide.strokeWidth = 2;

	});


	var myPath;


	function onMouseDown(event) {
		myPath = new Path();
		//myPath.strokeColor = 'black';
		//offset = event.point.x -minLeftSlideX +=;

		if(event.point.x >= (topSlide) && event.point.x <= (bottomSlide - offset)){
			if(event.point.x <= (topSlide + 20)) {
				slide.position.x = event.point.x + 125;
			} else {
				slide.position.x = event.point.x + 105;
			}
		}
		console.log("mousey");

	}

	function onMouseDrag(event) {
		myPath.add(event.point);
		rect.position.x = event.point.x;

		console.log(slide.bounds);

		//max and min slide range
		if(event.point.x >= (topSlide) && event.point.x <= (bottomSlide - offset)){

			if(event.point.x <= (topSlide + 20)) {
				slide.position.x = event.point.x + 125;
			} else {
				if(event.point.x >= (bottomSlide - (offset + 20))){
					slide.position.x = event.point.x + 115;
				}else {
					slide.position.x = event.point.x + 105;
				}
			}
		
			//slide.position.x += (event.point.x - (slide.bounds.width/2));
			
			//rect.position.x = (event.point.x + minLeftSlideX);
			//slide.position.x = (event.point.x + (slide.bounds.width/2)) - 4;


		//slide.position.x = slide.position.x + event.delta.length;
		// myPath.strokeColor = 'green';
	} else {
		// myPath.strokeColor = "black";
	}
		console.log(event.point.x);
		console.log("bott left" + slide.bounds.bottomLeft.x);

	}

	function onMouseUp(event) {
		// var myCircle = new Path.Circle({
		// 	center: event.point,
		// 	radius: 10
		// });
		// myCircle.strokeColor = 'black';
		// myCircle.fillColor = 'white';
	}

	//console.log('paper width ' + pWidth, 'paper height' + pHeight);

	globals.calcPosition = function(s){
		return seventh * s;
	};

	globals.moveSlide = function(s){

		var moveSlide = (slSvgSev * (s - 1))/1.77;
		var newSlidePos = initSlideX + moveSlide;

		slide.tween({
			'position.x': newSlidePos,
		}, {
			easing: 'easeInOutCubic',
		    duration: 200
		});

		console.log("newX " + newSlidePos);
		console.log(slideSeventh);
	};

	globals.tween = function(num) {
			
		rect.tween({
		    'position.x': num,
		    'fillColor.hue': '+= 90'
		}, {
		    easing: 'easeInOutCubic',
		    duration: 200
		});

		//console.log(slide.position, 'slSev ' + slSev);
	}

	function testing(){
		console.log("paper says hi");
	}
	 
	function onResize(event) {
	   // Whenever the window is resized, recenter the path:
	   //rect.position = view.center;
	}

	// console.log(paper.project._view._id); //paperScope object id
	paper.install(window);  //inject into window global scope

	</script>
</head>

<style>
#myCanvas {
	border: 2px solid red;
}

html,
body {
    height: 100%;
}

/* Scale canvas with resize attribute to full size */
canvas[resize] {
    width: 80vw;
    height: 90vh;

/*    width: 1156px;
    height: 529px;*/
}

</style>


<body>
	<h1 id="headline">Hello World!</h1>
	<canvas id="myCanvas" resize></canvas>


</body>
<script type="text/javascript">

	window.globals = {}

	let activeKey; //most recent key down
	let soundKeys = 0; //track pressed sound keys 
	let sound;
	let register = 0; //note ranges
	let keyData = {};
	let sliding; //sliding mouse
	//let activeSound = false; //active sound if mousedown

	window.onload = function(){

		keyData = {
			KeyA: {
		  		src: ['trombone/long/fLong.mp3', 'trombone/long/bFlatHighLong.mp3', 'trombone/long/bFlatLong.mp3'],
				pos: window.globals.calcPosition(1),
				num: 1
			},
			KeyS: {
		  		src: ['trombone/long/eLong.mp3', 'trombone/long/aLong.mp3', 'trombone/long/aLowLong.mp3'],
				pos: window.globals.calcPosition(2),
				num: 2
			},
			KeyD: {
		  		src: ['trombone/long/eFlatLong.mp3', 'trombone/long/aFlatLong.mp3', 'trombone/long/aFlatLowLong.mp3'],
				pos: window.globals.calcPosition(3),
				num: 3
			},
			KeyF: {
		  		src: ['trombone/long/dLong.mp3', 'trombone/long/gLong.mp3', 'trombone/long/gLowLong.mp3'],
				pos: window.globals.calcPosition(4),
				num: 4
			},
			KeyG: {
		  		src: ['trombone/long/dFlatLong.mp3', 'trombone/long/gFlatLong.mp3', 'trombone/long/gFlatLowLong.mp3'],
				pos: window.globals.calcPosition(5),
				num: 5
			},
			KeyH: {
		  		src: ['trombone/long/cLong.mp3', 'trombone/long/fLong.mp3', 'trombone/long/fLowLong.mp3'],		
				pos: window.globals.calcPosition(6),
				num: 6
			},
			KeyJ: {
		  		src: ['trombone/long/bLong.mp3', 'trombone/long/eLong.mp3', 'trombone/long/eLowLong.mp3'],  			
				pos: window.globals.calcPosition(7),
				num: 7
			}
		}

		document.addEventListener('mousedown', (e) => {
			sliding = true;
			// console.log('x ' + e.offsetX, 'y ' + e.offsetY);
			console.log("mousedown");

			if(e.offsetX > 250 && e.offsetX < 970){
			if(soundKeys === 0 && sliding){
				
					if(e.offsetX <= 365){
						activeKey = 'KeyA';
					}else
				
					if(e.offsetX <= 480){
						activeKey = 'KeyS';
					} else

					if(e.offsetX <= 595){
						activeKey = 'KeyD';
					} else

					if(e.offsetX <= 710){
						activeKey = 'KeyF';
					} else

					if(e.offsetX <= 825){
						activeKey = 'KeyG';
					} else

					if(e.offsetX <= 940){
						activeKey = 'KeyH';
					} else

					if(e.offsetX > 940 && e.offsetX <= 970 ){
						activeKey = 'KeyJ';
					} 
					playSound(activeKey);
					soundKeys++;
					return;
			
			} else {
				console.log("mouse down sliding " + sliding);
				console.log(soundKeys);
				return;
			}
		}//offset
		})

		document.addEventListener('mousemove', (e) => {
			let coorKey; //'key' change

			if(e.offsetX > 250 && e.offsetX < 960){
			if(sliding){
					if(e.offsetX <= 365){
						coorKey = 'KeyA';
					}else
				
					if(e.offsetX <= 480){
						coorKey = 'KeyS';
					} else

					if(e.offsetX <= 595){
						coorKey = 'KeyD';
					} else

					if(e.offsetX <= 710){
						coorKey = 'KeyF';
					} else

					if(e.offsetX <= 825){
						coorKey = 'KeyG';
					} else

					if(e.offsetX <= 940){
						coorKey = 'KeyH';
					} else

					if(e.offsetX > 940 ){
						coorKey = 'KeyJ';
					} 

					if(coorKey != activeKey){
						sound.fade(1,0,200);
						playSound(coorKey);
						activeKey = coorKey; 
					}

					console.log('x ' + e.offsetX, 'y ' + e.offsetY);
					console.log("mousemove");
					return;

			}else {
				//if not sliding
				console.log("mousemove not sliding " + sliding);
				return;

			}
			}
		})

		document.addEventListener('mouseup', (e) => {
			soundKeys--;
			sliding = false;
			console.log("mouseup");
			sound.fade(1,0,200);
			console.log("sliding: " + sliding);
			console.log("sound.playing mouseup " + sound.playing());
			activeKey = null;
			coorKey = null;
			return;
		})


	


		document.addEventListener('keydown', (e) => {
			keyed = e.code;

			
				if(e.repeat && activeKey) {  		//on held down sound key, check to repeat sound
					needsSoundRepeat();
				} else { 							//new key 							

					if((keyed === 'ArrowUp' || keyed === 'ArrowDown') && (activeKey)) { //to change note range 
							getRegister(keyed);
							sound.fade(1,0,300);
							playSound(activeKey);
							return;
					}
			
					if(keyData[keyed] && (!e.getModifierState('Meta')) && sliding === false){
						activeKey = keyed; //active sound key
						soundKeys++; //pressed sound key count
						if(soundKeys > 1){   //prevent sound overlap
							sound.fade(1,0,300);  
						} 

						playSound(activeKey);
						//square animation
						window.globals.tween(keyData[activeKey].pos);
						//slide animation
						window.globals.moveSlide(keyData[activeKey].num);
						return;
					} else {
						//console.log("no assigned sound");
						return;	
					}
				}	
				//console.log("down reported active key: " + activeKey);
		});

		document.addEventListener('keyup', (e) => {
			released = e.code;

			if((released === 'ArrowUp' || released === 'ArrowDown') && (activeKey)){
				register = 0;
				sound.fade(1,0,300);
				playSound(activeKey);
				return;
			}

			if(released === activeKey && sliding === false){
				soundKeys--;
				sound.fade(1,0,300);
				activeKey = null;
				return;

			} else {
				return;
			}
			//console.log("key up: " + e.key, "up reported activeKey: " + activeKey);
		});
	} //end window.onload

	function playSound(key) {  //play sound
		sound = new Howl({
			src: keyData[key].src[register],
			onfade: function(){
				this.stop();
			}
		});
		sound.play();
	}

	function getRegister(selected){  //change note range (high or low)
			(selected === 'ArrowUp') ? register = 1 : register = 2;
	}

	function needsSoundRepeat(){   //checks to see if getting close to sound track end to reset it with minimal lag
		let checkEnd = sound.duration() - 0.15; //point near end for range to catch seek 
		let currentPlace = sound.seek(); //current track seek placement
		if(currentPlace > checkEnd){ //are we getting close to end?
			sound.seek(0.15);  //reset seek to repeat 
		}
	}

</script>

</html>