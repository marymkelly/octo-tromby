<!DOCTYPE html>
<html>
<head>
	<title>Tromby - Trombone Simulator</title>
	<!-- Load the Paper.js library -->
	<script type="text/javascript" src="js/paper-full.js"></script>
	<script type="text/javascript" src="js/howler.js"></script>
	<!-- Define inlined PaperScript associate it with myCanvas -->
	<script type="text/paperscript" canvas="myCanvas">
	//paper/canvas variables
	var pWidth = view.bounds.width; 
	var pHeight = view.bounds.height;
	var midY = pHeight / 2;
	var midX = pWidth / 2;
	var pWidth3; // (pWidth / 3) - initSlideX

	//shape variables
	var width = 100;
	var height = 100;

	//trombone vars
	//var trombone;
	var bell; //recolor
	//var slide;
	var slideChild = {};  //recolor

	//calculate slide positions
	var initSlideX; //center X of slide - used
	var offset; // - used
	var slideSeventh; // equal division of 7 parts //116 each - used

	//slide svg relative ~ not canvas
	var topSlide; //initSlideX - offset; // 245 - static // top of slide and left bound of animation - used
	var bottomSlide; // 1085 - static - used
	var leftSlSvg; // ((slide.bounds.width / 2) - (pWidth / 3)); // left endpoint x of slide svg - used 
	var rightSlSvg; // ((slide.bounds.width / 2) + (pWidth / 3)); // right endpoint x of slide svg - used

	var trombone = paper.project.importSVG('/images/tspBell.svg', function(onload) { //background trombone image
		trombone = onload;
	
		trombone.bounds.width;
		trombone.position = new Point((pWidth / 3), midY);
		bell = trombone.children[1].children['Layer_4'].children[2];
		bell.fillColor = "#17FFEF";
		//console.log(trombone.children);
	});

	var slide = paper.project.importSVG('/images/tspSlide.svg', function(onload) { //animated trombone slide
		slide = onload;
		
		//console.log(slide.bounds);
		slide.position = new Point((pWidth / 3), midY); 
		pWidth3 = (pWidth / 3); // same as initial slide x
		initSlideX = slide.position.x; 

		leftSlSvg = ((slide.bounds.width / 2) - (pWidth / 3)); // left endpoint x of slide svg 
		rightSlSvg = ((slide.bounds.width / 2) + (pWidth / 3)); // right endpoint x of slide svg - bottom of slide - good
		offset = (pWidth * 0.0806); //from right side of canvas - used
		topSlide =  (pWidth * 0.2527);; // visual top of slide; should be fixed/closer //corrected sans resonsiveness
		bottomSlide = rightSlSvg; // good
		slideSeventh = (bottomSlide - topSlide) / 7; // corrected

		slideChild = slide.children[1].children['Layer_4'].children[0];
		slideChild.fillColor = "#17FFEF";

		// placement rectangle 
		// var rectPoint = new Point(initSlideX , (midY - (rectSize.height/2)));
		// var rectl = new Shape.Rectangle(new Point(topSlide ,(midY - (25/2))), new Size(25, 25));
		// rectl.fillColor = 'purple';
		//console.log("pW " + pWidth + "pH " + pHeight + "sl " + slide.bounds); 

	});

	function onMouseDown(event) {
		if(globals.conflict){
			return;
		} else if(event.event.button === 0) {
			globals.mouseDraggery(event);
		} return;
	}

	function onMouseDrag(event) {
		if(globals.conflict){
			return;
		} else if(event.event.button === 0) {
			globals.mouseDraggery(event);
		} return;
	}
	globals.mouseDraggery = function(event) {
		if(event.point.x >= (topSlide + 10) && event.point.x <= (bottomSlide - offset)){ //max and min slide range
			if((event.point.x > topSlide) && (event.point.x <= (topSlide + 40))) {
				slide.position.x = event.point.x + (offset - 10);
			}else if(event.point.x >= (bottomSlide - (offset + 10))){
					slide.position.x = event.point.x + offset;
			}else {
					slide.position.x = event.point.x + (offset - 10);
			}
		}
	}

	globals.getSlideX = function() {
		var clientSlide = slide.position.x - (pWidth * 0.0806); // calculate offset from current slide center x 
		return clientSlide;
	}

	globals.moveSlide = function(s){
		var moveSlide = (slideSeventh * (s - 1));
		var newSlidePos = initSlideX + moveSlide;

		slide.tween({
			'position.x': newSlidePos,
			
		}, {
			easing: 'easeInOutCubic',
		    duration: 200
		});

		bell.tween({
			'fillColor.hue': '+=5'
		}, {
			easing: 'easeInOutCubic',
		    duration: 200
		})

		slideChild.tween({
			'fillColor.hue': '+=5'
		}, {
			easing: 'easeInOutCubic',
		    duration: 200
		})

	};

	globals.backToFirst = function(){
		if(slide.position.x === topSlide){
			console.log('all good!');
		} else {
			console.log("working on it shortly");
			globals.moveSlide(1);
		}
	}

	function onResize(event) {
	// Whenever the window is resized, recenter the path:
	// slide.scale();
	// trombone.scale();
	slide.position = ({x: (view.bounds.width/3), y: (view.bounds.height/2)});
	trombone.position = ({x: (view.bounds.width/3), y: (view.bounds.height/2)}); 
	
	//console.log(slideChild.bounds.width)
	console.log(slideChild);
	console.log(slide);

	}
	// console.log(paper.project._view._id); //paperScope object id
	paper.install(window);  //inject into window global scope

	</script>
	<link href="https://fonts.googleapis.com/css2?family=Open+Sans&family=Sacramento&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Open+Sans&display=swap" rel="stylesheet">
</head>

<style>
#myCanvas {
	/*border: 2px solid red;*/
}

html,
body {
    height: 100%;
    width: 100%;
    padding: 0;
    margin: 0;
/*    font-family: 'Open Sans', sans-serif;
	font-family: 'Sacramento', cursive;*/
	font-family: 'Architects Daughter', cursive;
	/*font-family: 'Open Sans', sans-serif;*/
    color: white;
    overflow: hidden;
    background: #000428;  /* fallback for old browsers */
	background: -webkit-linear-gradient(to right, #004e92, #000428);  /* Chrome 10-25, Safari 5.1-6 */
	background: linear-gradient(to right, #004e92, #000428); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */

}

/* Scale canvas with resize attribute to full size */
canvas[resize] {
    width: 100vw;
    height: 100vh;
    display: block;
    padding-left: 0;
    padding-right: 0;
    margin-left: auto;
    margin-right: auto;
}

#bg{
	clip-path: polygon(15% 88%, 86% 87%, 100% 100%, 0% 100%);
	height: 100vh;
	width: 100vw;
	background-color: navy;
	/*background-color: #111;*/
	position: absolute;
}

#placeholder {
	left: 50px;
	position: absolute;
}
</style>


<body>
	<!-- <div id="bg"></div> -->
	<div id="placeholder">
	<h1 id="headline">Note: <span id="note"></span></h1>
	</div>
	<canvas id="myCanvas" resize></canvas>
</body>
<script type="text/javascript">

	window.globals = {
		start: (window.innerWidth * 0.23),
		end: (window.innerWidth * 0.81),
		conflict: true
	}

	let keyData = {
			KeyA: {
		  		src: [{note: 'F', track: 'trombone/long/fLong.mp3'}, {note: 'B Flat', track: 'trombone/long/bFlatHighLong.mp3'},{note: 'B Flat', track: 'trombone/long/bFlatLong.mp3'}],
				num: 1,
				key: 'KeyA',
				pressed: false
			},
			KeyS: {
		  		src: [{note: 'E' , track: 'trombone/long/eLong.mp3'}, {note: 'A', track: 'trombone/long/aLong.mp3'}, {note: 'A', track: 'trombone/long/aLowLong.mp3'}],
				num: 2,
				key: 'KeyS',
				pressed: false
			},
			KeyD: {
		  		src: [{note: 'E Flat', track: 'trombone/long/eFlatLong.mp3'}, {note: 'A Flat', track: 'trombone/long/aFlatLong.mp3'}, {note: 'A Flat', track: 'trombone/long/aFlatLowLong.mp3'}],
				num: 3,
				key: 'KeyD',
				pressed: false
			},
			KeyF: {
		  		src: [{note: 'D', track: 'trombone/long/dLong.mp3'}, {note: 'G', track: 'trombone/long/gLong.mp3'}, {note: 'G', track: 'trombone/long/gLowLong.mp3'}],
				num: 4,
				key: 'KeyF',
				pressed: false
			},
			KeyG: {
		  		src: [{note: 'D Flat', track: 'trombone/long/dFlatLong.mp3'}, {note: 'G Flat', track: 'trombone/long/gFlatLong.mp3'}, {note: 'G Flat', track: 'trombone/long/gFlatLowLong.mp3'}],
				num: 5,
				key: 'KeyG',
				pressed: false
			},
			KeyH: {
		  		src: [{note: 'C', track: 'trombone/long/cLong.mp3'}, {note: 'F', track: 'trombone/long/fLong.mp3'}, {note: 'F', track: 'trombone/long/fLowLong.mp3'}],		
				num: 6,
				key: 'KeyH',
				pressed: false
			},
			KeyJ: {
		  		src: [{note: 'B', track: 'trombone/long/bLong.mp3'}, {note: 'E', track: 'trombone/long/eLong.mp3'}, {note: 'E', track: 'trombone/long/eLowLong.mp3'}],  			
				num: 7,
				key: 'KeyJ',
				pressed: false
			},
			ArrowLeft: {
				key: 'ArrowLeft',
				pressed: false
			},
			ArrowRight: {
				key: 'ArrowRight',
				pressed: false
			}
		};

	let activeKey; //most recent key down
	let soundKeys = 0; //track pressed sound keys 
	let sound;
	let register = 0; //note ranges
	let sliding = false; //sliding mouse
	let coorKey; //corresponding 'key' 
	let activeSound = false; //active sound if mousedown
	let pressedKeys = false; //tracking pressed keys
	
	let mouseUp; 
	let mouseDown;
	let mouseMove;
	let keyDown;
	let keyUp;

	let pointerDown = new PointerEvent("pointerdown", 
	   {
	   	bubbles: true, 
	    cancelable: true, 
	    pointerType: "touch",
	    // isPrimary: true
	}); 
	let pointerMove = new PointerEvent("pointermove");
	let pointerUp = new PointerEvent("pointerup");
	let timeoutID;

	window.onload = function(){

		mouseDown = document.addEventListener('mousedown', handler);
		mouseMove = document.addEventListener('mousemove', handler);
		mouseUp = document.addEventListener('mouseup', handler);
		keyDown = document.addEventListener('keydown', handler);
		keyUp = document.addEventListener('keyup', handler);
		arrowKey = document.addEventListener('keydown', handler);
		pointerDown = document.addEventListener('pointerdown', handler);
		pointerMove = document.addEventListener('pointermove', handler);
		pointerUp = document.addEventListener('pointerup', handler);

		document.addEventListener('keydown', (e)=> { //listen on key down for keys pressed
			if(keyData[e.code]) {
				keyData[e.code].pressed = true;
				pressedKeys = true;
			}
		})

		document.addEventListener('keyup', (e)=> { //listen on key up for keys pressed
			pressedKeys = false;
			if(keyData[e.code]) {
				keyData[e.code].pressed = false;
			}

			for (const [key, value] of Object.entries(keyData)) {
				 if(value['pressed'] == true){
			 		pressedKeys = true;
				 }
			}
		})
	} //end window.onload



	//TESTING FUNCTIONS
	let title = document.getElementById("headline");
	let note = document.getElementById("note");

	title.addEventListener("click", (e) => {
		for (const [key, value] of Object.entries(keyData)) {
		 console.log(`${key}: ${value['pressed']}`);
			 if(value['pressed'] == true){
		 		console.log(`${key}`);
			 }
		}
		console.log('pr' + pressedKeys, 'ct' + keyCount);

	
	})

	//KEYBOARD EVENT FUNCTIONS

	function callKeyE(event) { //key "router"
			if ((event.code === 'ArrowLeft') || (event.code === 'ArrowRight')){
		    	(event.type === 'keydown') ? arrowSlide(event.code) : callKeyRelease(activeKey); 
		    	return;
		    } else

		    if(keyData[event.code] && (!event.getModifierState('Meta'))) {
				(event.type === 'keydown') ? callKeyMovement(event.code) : callKeyRelease(event.code);
				return;
			} 
	}

	function callKeyMovement(keyed) {  //call slide postition movement based off key
		activeKey = keyed; //active sound key
					soundKeys++; //pressed sound key count
					if(soundKeys > 1){   //prevent sound overlap
						soundKeys--;
						sound.fade(1,0,300);  
					} 
					playSound(activeKey);
					//slide animation
					window.globals.moveSlide(keyData[activeKey].num);
					return;
	}

	function callKeyRelease(released){  //if key released
		console.log("keyrelease");
		if((released === activeKey)){
				soundKeys--;
				pressedKey = false;
				sound.fade(1,0,300);
				activeKey = null;
				note.innerHTML = '';
			}
			return;
	}

	//ARROW KEY FUNCTIONS

	function arrowSlide(arrow) {
		let coorKey = getKey(window.globals.getSlideX());
		let coorNum = keyData[coorKey].num;
		let nextPos = getStep(arrow, keyData[coorKey].num);

		coorNum = nextPos;

		let objArr = Object.values(keyData);
		let nextKey;

		for(var i = 0; i < objArr.length; i++){
			if(objArr[i].num === coorNum){
				nextKey = objArr[i].key;
			}
		}
		callKeyMovement(nextKey);
		return;
	}

	//MOUSE EVENT HANDLERS

	function callMouseE(event) { //mouse "router"
		if(event.button === 0){
			if(event.type === 'mousedown' || event.type === "pointerdown"){
				callMouseDown(event);
				return;
			} else if(event.type === 'mousemove' || event.type === "pointermove"){
				callMouseMove(event);
				return;
			} else if(event.type === 'mouseup' || event.type === "pointerup") {
				callMouseUp(event);	
				return;
				// callRelease(event);
			} 
		} else {
			//event.preventDefault();
		}
	} 
	

	function callMouseDown(e) {  //on mouse down - mainly sound handler
		if(soundKeys === 0) {  //if there is an active sound 
			sliding = true;
			window.globals.conflict = false;
			if(e.offsetX > window.globals.start && e.offsetX < window.globals.end) {
				if(activeSound){	
					sound.fade(1,0,200);
				}
				activeKey = getKey(e.offsetX);
				playSound(activeKey);
				return;
			} 
		} else {
			window.globals.conflict = true;
			sliding = false;
			return;
		}
	}

	//MOUSE EVENT FUNCTIONS

	function callMouseMove(e) {  //on mouse move - cooresponding sound handler (movement handled in paperscript)
		if(soundKeys === 0){	
			if(sliding === true){
				window.globals.conflict = false; //disable paperjs from moving slide
				if(e.offsetX > window.globals.start && e.offsetX < window.globals.end){
					coorKey = getKey(e.offsetX);

					if(coorKey != activeKey){
						sound.fade(1,0,300);
						activeKey = coorKey; 
						playSound(activeKey);
						return;	
					}			
				}else {  //if outside side bounds
					window.globals.conflict = true;
					console.log("mousemove not slide not moving // out of bounds " + sliding);
					return;
				}
			}
		}
	}

	function callMouseUp(e) {  // on mouse up
		if(sliding){
		sliding = false;
		window.globals.conflict = true;
		sound.fade(1,0,200);
		activeSound = false;
		activeKey = null;
		}
		note.innerHTML = '';
		return;
	}
	
	//SOUND FUNCTIONS

	function playSound(key) {  //play sound
		sound = new Howl({
			src: keyData[key].src[register].track,
			onfade: function(){
				sound.off(); //sound.off not stop
				activeSound = false;
			}
		});
		sound.play();
		activeSound = sound.playing();

		note.innerHTML = keyData[key].src[register].note; 
		return;
	}

	function needsSoundRepeat(){   //if key is held on repeat - checks to see if getting close to sound track end to reset it with minimal lag
		let checkEnd = sound.duration() - 0.15; //point near end for range to catch seek 
		let currentPlace = sound.seek(); //current track seek placement
		if(currentPlace > checkEnd){ //are we getting close to end?
			sound.seek(0.15);  //reset seek to repeat 
		}
	}

	//COORESPONDING VALUES/ CONVERSION FUNCTIONS

	function getKey(num){ //get cooresponding sounds from key data when sliding

		let key;

		let seventh = (window.innerWidth * 0.58) / 7;
		let start = (window.innerWidth * 0.23);
		let end = (window.innerWidth * 0.81);

		// num > (window.innerWidth * 0.23)) && (num <= (window.innerWidth * 0.26) //initial grab span should be between this

		if((num > start) && (num <= (start + (seventh * 1)))){  //<26% width client width 
			key = 'KeyA';
		} else
	
		if(num <= (start + (seventh * 2))) { 
			key = 'KeyS';
		} else

		if(num <= (start + (seventh * 3))) { 
			key = 'KeyD';
		} else

		if(num <= (start + (seventh * 4))) { 
			key = 'KeyF';
		} else

		if(num <= (start + (seventh * 5))) { 
			key = 'KeyG';
		} else

		if(num <= (start + (seventh * 6))) { 
			key = 'KeyH';
		} else

		if((num > (start + (seventh * 6))) && (num < (end))) { 
			key = 'KeyJ';
		} 
		return key;	
	}

	function getRegister(selected){  //change note range (high or low)
			(selected === 'ArrowUp') ? (register = 1) : (register = 2);
	}

	function getStep(selected, num){  //change slide position from left or right arrow keys		
			if((num >= 1) && (num <= 7)) {
				if(selected === 'ArrowLeft') {
					(num > 1) ? num-- : (num = 1);
				}else if(selected === 'ArrowRight'){
					(num < 7) ? num++ : (num = 7); 
				} else {
					console.log("error");
				}
			} else {
				console.log("number is, somehow, out of bounds");
				return;
			}
			return num; 
	}

	//INACTIVITY AND OTHER OPERATIONAL FUNCTIONS


	function handler(event) {
			//console.log(event);
			//clearAlert();
			//console.log(document.readyState);
			if(event.repeat){ 
				needsSoundRepeat();
				return;
			} else {		
			    	if((event.code === 'ArrowUp') || (event.code === 'ArrowDown')){	
			    		(event.type === 'keydown') ? getRegister(event.code) : (register = 0);
				    	
			    		if(sliding || pressedKeys) {
				    		sound.fade(1,0,300);
				    		playSound(activeKey);	
			    		}
			    		return;
				    }

					if(!checkConflict(event)){
						if(MouseEvent || PointerEvent){
							callMouseE(event);
						}
						if(KeyboardEvent){
							callKeyE(event);
							return;
						}
					} else {
						console.log("bypassed");
						return;
					}
				}
				
		   // timeOutID = setTimeout(() => {window.globals.backToFirst();}, 5000);
		}

	const checkConflict = (e) => {
			let conflict = false;
			let letter;
	
			if(!sliding && !pressedKeys){ //if nothing pressed
				return false;
			} else if (sliding && keyData[e.code]){ //if mouse is already sliding and try to press directional key
				conflict = true;
			} else if(pressedKeys && MouseEvent.type === 'mousedown'){  // if directional key is already down and try to override with mouse
				conflict = true;
			} else if(keyData[e.code]) { 
				for (const [key, value] of Object.entries(keyData)) { //if A - J is pressed
				    if((value['pressed'] == true) && (key != 'ArrowLeft' && key != 'ArrowRight')) { 
				 		letter = true;
			 		}
			 	}	 
				if((e.code != 'ArrowLeft' && e.code != 'ArrowRight') && (keyData.ArrowLeft.pressed || keyData.ArrowRight.pressed)){ //if arrow key is already pressed and try to press A-J
						conflict = true;
				}else if((letter) && (e.code == 'ArrowLeft' || e.code == 'ArrowRight')){ // if A-J is already pressed and try to press arrow key
					conflict = true;
				}else if(keyData.ArrowLeft.pressed && keyData.ArrowRight.pressed){ //both arrow direction keys are pressed
					conflict = true;
				}
			}
			return conflict; 
		}

	function clearAlert() {
		window.clearTimeout(timeoutID);
	}

</script>

</html>